---
phase: 02-pdf-architektur
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - package.json
  - src/services/imageService.js
  - src/services/pdf/pages/componentPage.js
  - src/services/pdf/pages/haustypPage.js
  - src/services/pdf/pages/titlePage.js
  - src/services/pdfService.js
autonomous: true

must_haves:
  truths:
    - "sharp is a production dependency (in dependencies, not devDependencies)"
    - "Product images are compressed to under 400 KB before PDF embedding"
    - "Images with alpha channels (PNG transparency) stay as PNG, photographic images convert to JPEG"
    - "Placeholder images (< 10 KB) are not processed by sharp"
    - "Generated PDFs are measurably smaller than before compression"
    - "imageService cache is cleared after each PDF generation"
  artifacts:
    - path: "src/services/imageService.js"
      provides: "Image compression pipeline with sharp"
      exports: ["getCompressedImage", "clearCache"]
    - path: "package.json"
      provides: "sharp in production dependencies"
      contains: "\"sharp\""
  key_links:
    - from: "src/services/pdf/pages/componentPage.js"
      to: "src/services/imageService.js"
      via: "require or ctx.imageService"
      pattern: "imageService"
    - from: "src/services/pdfService.js"
      to: "src/services/imageService.js"
      via: "require('./imageService')"
      pattern: "require\\('./imageService'\\)"
---

<objective>
Create an imageService.js with sharp-based image compression (resize + format-aware compress + in-memory cache), move sharp from devDependencies to production dependencies, and wire the image service into the PDF page modules that embed product images (componentPage, haustypPage, titlePage).

Purpose: Product images (38 MB total, up to 5.5 MB each, 1920px+ wide) are currently embedded raw into PDFs, producing 24 MB files. After compression (resize to max 800px, JPEG at quality 75 for photos, PNG compression for transparent images), PDFs will drop below 5 MB. This is the TECH-02 requirement.

Output: imageService.js with getCompressedImage/clearCache, sharp in production deps, page modules using compressed images.
</objective>

<execution_context>
@C:/Users/LehnerJ.LEHNER-HAUS/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/LehnerJ.LEHNER-HAUS/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-pdf-architektur/02-RESEARCH.md
@.planning/phases/02-pdf-architektur/02-02-SUMMARY.md
@src/services/imageService.js
@src/services/pdf/pages/componentPage.js
@src/services/pdf/pages/haustypPage.js
@src/services/pdf/pages/titlePage.js
@src/services/pdfService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Move sharp to production dependency and create imageService.js</name>
  <files>
    package.json
    src/services/imageService.js
  </files>
  <action>
**Part A: Move sharp to production dependencies**

Run: `npm install sharp@^0.34.5 --save`

This moves sharp from devDependencies to dependencies. Verify in package.json that `"sharp"` appears under `"dependencies"` (not `"devDependencies"`). If it still appears in devDependencies, manually remove it from there.

**Part B: Create `src/services/imageService.js`**

```javascript
const sharp = require('sharp');
const fs = require('fs');
const path = require('path');

const cache = new Map();

/**
 * Compress and resize an image for PDF embedding.
 * - Skips tiny images (< 10 KB) — likely placeholders
 * - Keeps PNG for images with alpha channel (technical drawings)
 * - Converts to JPEG for photographic images (no transparency)
 * - Resizes to maxWidth while preserving aspect ratio
 * - Caches results in memory (cleared per PDF generation)
 *
 * @param {string} imagePath - Absolute path to image file
 * @param {number} maxWidth - Maximum width in pixels (default 800)
 * @returns {Promise<Buffer|null>} Compressed image buffer, or null if file missing
 */
async function getCompressedImage(imagePath, maxWidth = 800) {
  if (!imagePath || !fs.existsSync(imagePath)) return null;

  const cacheKey = `${imagePath}:${maxWidth}`;
  if (cache.has(cacheKey)) return cache.get(cacheKey);

  const stats = fs.statSync(imagePath);

  // Skip tiny images (placeholders are ~3 KB)
  if (stats.size < 10240) {
    const buf = fs.readFileSync(imagePath);
    cache.set(cacheKey, buf);
    return buf;
  }

  try {
    const metadata = await sharp(imagePath).metadata();

    let pipeline = sharp(imagePath)
      .resize(maxWidth, null, { fit: 'inside', withoutEnlargement: true });

    if (metadata.hasAlpha) {
      // Keep PNG for images with transparency (technical drawings)
      pipeline = pipeline.png({ compressionLevel: 8 });
    } else {
      // Convert to JPEG for photos (much smaller)
      pipeline = pipeline.jpeg({ quality: 75, mozjpeg: true });
    }

    const buffer = await pipeline.toBuffer();
    cache.set(cacheKey, buffer);

    const reduction = ((stats.size - buffer.length) / stats.size * 100).toFixed(0);
    console.log(`[Image] Compressed ${path.basename(imagePath)}: ${(stats.size / 1024).toFixed(0)} KB → ${(buffer.length / 1024).toFixed(0)} KB (${reduction}% reduction)`);

    return buffer;
  } catch (err) {
    console.error(`[Image] Compression failed for ${imagePath}:`, err.message);
    // Fallback: return raw file
    const buf = fs.readFileSync(imagePath);
    cache.set(cacheKey, buf);
    return buf;
  }
}

/**
 * Clear the image cache. Call after each PDF generation.
 */
function clearCache() {
  cache.clear();
}

module.exports = { getCompressedImage, clearCache };
```

Key design decisions (from research):
- maxWidth=800 is generous for PDF embedding (images render at max 180px at 72 DPI, so 800px is ~4x oversampling for quality)
- JPEG quality 75 with mozjpeg provides excellent compression with minimal visible quality loss
- PNG compressionLevel 8 (out of 9) for lossless compression of transparent images
- Error fallback reads raw file rather than breaking PDF generation
- Console logging for compression stats aids debugging
  </action>
  <verify>
1. Run `node -e "const img = require('./src/services/imageService'); console.log(Object.keys(img));"` — expect `['getCompressedImage', 'clearCache']`
2. Run `node -e "const img = require('./src/services/imageService'); img.getCompressedImage('./assets/variants/walls/climativ.png').then(buf => console.log('Compressed size:', buf.length, 'bytes'));"` — expect a buffer significantly smaller than the original file
3. Check `grep '"sharp"' package.json` shows sharp in dependencies section
  </verify>
  <done>imageService.js exists with getCompressedImage and clearCache exports. sharp is in production dependencies. Compression works for test images.</done>
</task>

<task type="auto">
  <name>Task 2: Wire imageService into page modules and orchestrator</name>
  <files>
    src/services/pdf/pages/componentPage.js
    src/services/pdf/pages/haustypPage.js
    src/services/pdf/pages/titlePage.js
    src/services/pdfService.js
  </files>
  <action>
**Part A: Update pdfService.js orchestrator**

Add imageService to the orchestrator:

1. Add import: `const imageService = require('./imageService');`
2. Add imageService to ctx: change `const ctx = { pageNum: 0, catalogService };` to `const ctx = { pageNum: 0, catalogService, imageService };`
3. After `doc.end();`, add: `imageService.clearCache();`

**Part B: Update componentPage.js**

In the render function, find every `doc.image(imagePath, ...)` call where `imagePath` is a product image from the catalog (filePath or technicalDrawing). Replace with compressed image:

Before (pattern):
```javascript
if (fs.existsSync(imagePath)) {
  doc.image(imagePath, x, y, { width: w, height: h });
}
```

After (pattern):
```javascript
const imageService = ctx.imageService;
if (fs.existsSync(imagePath)) {
  const buffer = await imageService.getCompressedImage(imagePath);
  if (buffer) {
    doc.image(buffer, x, y, { width: w, height: h });
  } else {
    layout.drawImagePlaceholder(doc, x, y, w, h, categoryTitle);
  }
}
```

IMPORTANT: Since `getCompressedImage` is async, the `render` function in componentPage.js must become `async`. Update the module export:
```javascript
module.exports = {
  async renderComponent(doc, component, title, chapter, ctx) { ... }
};
```

PDFKit's `doc.image()` accepts a `Buffer` directly (verified in PDFKit docs and research). The coordinates and dimensions stay EXACTLY the same.

Apply this to ALL `doc.image()` calls in componentPage.js that reference catalog images (component.filePath, component.technicalDrawing). There are typically 2 image calls: one for the product image and one for the technical drawing.

**Part C: Update haustypPage.js**

Same pattern as componentPage.js. The haustyp page loads 3 images from the haustyp directory (1.png, 2.png, 3.png). Replace each `doc.image(imgPath, ...)` with the compressed buffer version.

Make `renderHaustyp` async:
```javascript
module.exports = {
  async renderHaustyp(doc, component, ctx) { ... }
};
```

**Part D: Update titlePage.js**

The title page loads the Lehner Haus logo. This is a branding image, not a product image, but it can still benefit from compression. Replace `doc.image(logoPath, ...)` with:
```javascript
const imageService = ctx.imageService;
const buffer = await imageService.getCompressedImage(logoPath, 500); // Higher maxWidth for logo quality
if (buffer) {
  doc.image(buffer, 172.5, 100, { width: 250 });
}
```

Make `render` async in titlePage.js.

CRITICAL RULES:
- Do NOT change any coordinates, widths, heights, or layout positions
- Only change the image SOURCE from file path to compressed buffer
- Every render function that uses imageService must be async
- The fallback for missing/failed images should use layout.drawImagePlaceholder (componentPage, haustypPage) or the existing text fallback (titlePage)
  </action>
  <verify>
1. `node -e "require('./src/services/pdfService')"` loads without error
2. Start server, submit a full configuration (with haustyp, walls, windows, etc.). Generate PDF.
3. Check generated PDF file size. Compare to pre-compression baseline (~24 MB for full config). The compressed PDF should be significantly smaller (target: under 5 MB).
4. Open the PDF and visually verify:
   - Product images appear in correct positions with correct dimensions
   - Image quality is acceptable (no pixelation or artifacts visible at normal zoom)
   - Technical drawings with transparency render correctly (no white rectangles)
   - Logo on title page renders correctly
   - Placeholder images (daecher, treppen with 3 KB placeholders) render correctly
5. Check console output for `[Image] Compressed ...` log lines showing compression ratios
  </verify>
  <done>All page modules that embed images use imageService for compression. PDF generation produces compressed images. Generated PDFs are measurably smaller. Image quality is visually acceptable. The imageService cache is cleared after each generation.</done>
</task>

</tasks>

<verification>
1. `grep -A2 '"sharp"' package.json` shows sharp under dependencies (not devDependencies)
2. `node -e "require('./src/services/imageService')"` loads without error
3. `node -e "require('./src/services/pdfService')"` loads without error
4. Full-config PDF is under 5 MB (down from ~24 MB)
5. Visual spot-check: images look good, no broken layouts, no missing images
6. Console shows `[Image] Compressed` messages during PDF generation
7. Placeholder images (< 10 KB) pass through without sharp processing
</verification>

<success_criteria>
- sharp is a production dependency
- imageService.js exports getCompressedImage and clearCache
- All product images in PDFs are compressed (resize to 800px max, JPEG for photos, PNG for transparent)
- Generated PDFs are measurably smaller than before (target: ~5x reduction for full-config PDFs)
- Image quality is visually acceptable
- Cache is cleared after each PDF generation
</success_criteria>

<output>
After completion, create `.planning/phases/02-pdf-architektur/02-03-SUMMARY.md`
</output>
